---
title: Redis高频面试题
date: 2022-06-20 10:45:52
categories: 
 - DB
 - Redis
tags: 
 - Redis高频面试题
---

# Redis高频面试题

## 1.什么是 Redis，有什么优缺点？

```
Redis是一个 键值(Key-Value) 类型的NoSQL数据库。
SQL:Structured Query Language
NoSQL:Not Only SQL/non-relational

Redis优点
1.基于内存操作，因此读写速度非常快；
2.支持丰富的数据结构，string、hash、list、set、zset(sorted set)；
3.支持事务，而且操作都是原子性；
4.按key设置过期时间，到期后自动删除；
5.支持主从(master-slave)复制来实现数据备份，主机会自动将数据同步到从机。
Redis缺点
内存成本相对硬盘较高。
```
## 2.Redis 适用场景，项目中哪些地方用到了 Redis?

> **换个问法：项目中为什么要用 Redis？哪些地方用到了Redis？**

```
项目中为什么要用Redis可以这样来回答：
一般情况下，Redis 是用来实现应用和数据库之间的一个读操作的缓存层，主要目的是去减少数据库的IO，还可以提升数据的IO性能，当应用程序需要去读取某个数据的时候，首先会尝试从 Redis 里面加载，如果命中了就直接返回，如果没有命中就直接从数据库里面查询，查询到数据之后，再把数据缓存到 Redis中。

在项目中使用 Redis，主要解决关系型数据库的高并发(线程安全,性能）问题。
线程安全：redis单线程机制，因此多个命令不会导致线程安全问题。
性能：所有操作基于内存，单用单线程避免线程之间竞争，采用了多路复用非阻塞IO，所以性能相对于关系型数据库更好。

基于上面的两个角度我们可以总结出Redis适用的场景（以下举例都可以说成是项目中实际用到Redis的地方）
场景一：缓存
1.缓存会话数据：可以将用户当前会话的一些临时数据保存到Redis，当用户结束会话时，才对相关数据才进行持久化存储。如：购物车数据
2.缓存热点数据：经常会被查询，但是不经常被修改或者删除的数据，我们可以将其放入Redis。如：数据字典、商品分类(注意：这类场景下，当数据修改后，需要同步Redis)
3.缓存临时数据：当一些数据只需要在某一段时间内使用，过期后自动删除(通过expire设置过期时间)。
如：系统验证码、手机验证码、token

场景二：计数器
1.由于单线程，可以避免并发问题，保证不会出错，而且100%毫秒级性能。如：统计点击数、访问数

场景三：分布式锁与单线程机制
1.验证前端的重复请求：可以通过 Redis 进行过滤，每次请求将请求IP、参数、接口等hash作为key存储redis（幂等性请求），设置多长时间有效期，然后下次请求过来的时候先在redis中检索有没有这个key，进而验证是不是一定时间内过来的重复提交。
2.秒杀系统：基于 Redis 是单线程特征，防止出现数据库“爆破”
3.全局增量ID生成：类似“秒杀”

场景四：队列
1.相当于 RabbitMQ，RocketMQ 等消息中间件，但是如果对于数据一致性要求高的话还是用 RabbitMQ等 MQ。
2.由于 Redis 把数据添加到队列是返回添加元素在队列的第几位，所以可以做判断用户是第几个访问这种业务
3.队列不仅可以把并发请求变成串行，并且还可以做队列或者栈使用

场景五：注册中心(只有想不到，没有做不到)
```

## 3.Redis 数据结构，适用场景？

```
Redis数据结构：string、hash、list、set、zset(sorted set)

1.string
介绍：string 数据结构是简单的key-value类型，value其实不仅可以是string，也可以是数字。
常用命令：set、get、decr、incr、mget 等
适用场景：系统验证码、手机验证码、token、点击数、访问数等

2.hash
介绍：hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，可以直接仅仅修改这个对象中的某个字段的值。
常用命令：hget、hset、hgetall 等
适用场景：购物车数据、商品分类、数据字典等

3.list
介绍：list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。
常用命令：lpush、rpush、lpop、rpop、lrange 等
适用场景：消息队列、微博关注列表，粉丝列表、高性能分页（比如下拉刷新）

4.set
介绍：set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动去重。当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。
常用命令：sadd、spop、smembers、sunion 等
适用场景：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。在项目中没有用到该结构。

5.zset(sorted set)
介绍：在去重的基础上，zset 增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。
常用命令：zadd、zrange、zrem、zcard 等
适用场景：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 zset 结构进行存储。在项目中没有用到该结构。
```
[参考：Redis 五大数据结构](https://juejin.cn/post/7058900670858035208)

## 4.Redis 是单线程的吗？
```
Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写由一个线程来完成，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实都是由额外的线程执行的。
```

**问题延伸**

> Redis 是单线程的，为什么那么快?

```
1.完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)
2.采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
3.使用多路 I/O 复用模型，非阻塞 IO
4.数据结构设计思路是空间换时间。

一句话回答：
因为所有操作基于内存，单用单线程避免线程之间竞争，采用了多路复用非阻塞IO。
```

> Redis 单线程如何处理那么多的并发客户端链接？

```
Redis 的IO多路复用：Redis 利用 epoll 来实现 IO 多路复用，将链接信息和事件放到队列中，依次放
到事件分派器，事件分派器将事件分发给事件处理器。
```

![image-20220620113043699](https://gcore.jsdelivr.net/gh/znej/pic/picgo/image-20220620113043699.png)

## 5.Redis 缓存雪崩、缓存穿透、缓存击穿？

[参考](https://juejin.cn/post/7059949724152889380) 

### 缓存雪崩

**什么是缓存雪崩？**

```
缓存雪崩是指在短时间内，有大批量key过期(失效)或者缓存层出错，导致大量的请求直接查询数据库，从
而对数据库造成了巨大的压力，导致数据库宕机的情况叫做缓存雪崩。
```

![image-20220620113506386](https://gcore.jsdelivr.net/gh/znej/pic/picgo/image-20220620113506386.png)

**原因&解决方案**

1. **大批量key同时过期**
   - 方案一：加锁排队
   - 方案二：随机化过期时间
     为了避免缓存同时过期，可在**设置缓存时添加随机时间** ，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就可以极大的避免大量的缓存同时失效。

     ```java
     // 缓存原本的失效时间 
     int exTime = 10 * 60 ;
     // 随机数生成类
     Random random = new Random();
     // 缓存设置
     jedis.setex(cacheKey, exTime + random.nextInt( 1000 ) , value);
     ```
   - 方案三：过期延时

   - 方案四：设置本地缓存

   - 方案五：缓存永不过期

2. **缓存层出错**

   ```
   Redis高可用：Redis有可能挂掉，那就多增加几台Redis，实现Redis集群（主从同步），保证高可用。
   ```

### 缓存穿透

**什么是缓存穿透？**

```
缓存穿透是指查询数据库和缓存都无数据，因为数据库查询无数据，出于容错考虑，不会将结果保存到缓存中，因此每次请求都会去查询数据库，并且返回为空，这种情况就叫做缓存穿透。
```

**解决方案？**

1. 缓存空数据。

   - 我们可以把每次从数据库查询的数据都保存到缓存中（如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库），为了提高前台用户的使用体验 (解决长时间内查询不到任何信息的情况)，我们可以将空结果的缓存时间设置得短一些，例如 3~5 分钟。这种办法最简单粗暴，适合少量key情况。

     ![image-20220620115729379](https://gcore.jsdelivr.net/gh/znej/pic/picgo/image-20220620115729379.png)

2. 使用布隆过滤器（Bloom Filter）

   - 我们可以使用布隆过滤器来减少对数据库的请求，布隆过滤器的原理是将数据库的数据哈希到 bitmap中，每次查询之前，先使用布隆过滤器过滤掉一定不存在的无效请求，从而避免了无效请求给数据库带来的查询压力。

     ![image-20220620190213554](https://gcore.jsdelivr.net/gh/znej/pic/picgo/image-20220620190213554.png)

[Redis 布隆过滤器](https://juejin.cn/post/7058511684716986382)

### 缓存击穿

**什么是缓存击穿？**

```
缓存击穿指的是某个热点缓存，在某一时刻恰好失效了，然后此时刚好有大量的并发请求，此时这些请求将会给数据库造成巨大的压力，这种情况就叫做缓存击穿。缓存击穿和缓存雪崩的区别在于缓存击穿针对某一key缓存，缓存雪崩则是很多key。
```

**解决方案？**

- 方案一：**加锁排队**
  - **加锁排队可以起到缓冲的作用** ，防止大量的请求同时操作数据库，但它的缺点是**增加了系统的响应时间 ， 降低了系统的吞吐量** ，牺牲了一部分用户体验。
  - 思路 ：当缓存未查询到时，对要请求的 key 进行加锁，只允许一个线程去数据库中查，其他线程等候排队，这里的加锁逻辑就类似于单例模式的双重校验锁。
  - **注意：如果是分布式架构，也就是服务集群，不能采用本地锁，必须得使用 Redis 的分布式锁 。**

	  ```java
	  // 缓存 key
	  String cacheKey = "userlist";
	  // 查询缓存
	  String data = jedis.get(cacheKey);
	  if (StringUtils.isNotBlank(data)) {
	  	// 查询到数据，直接返回结果
	  	return data;
	  } else {
	  	// 先排队查询数据库，再放入缓存
	  	synchronized (cacheKey) {
	  		data = jedis.get(cacheKey);
	  		if (!StringUtils.isNotBlank(data)) { // 双重判断
	  			// 查询数据库
	  			data = findUserInfo();
	  			// 放入缓存
	  			jedis.set(cacheKey, data);
	  		}
	  		return data;
	  	}
	  }
	  ```

- 方案二：**设置永远不过期**
  - 对于某些热点缓存，我们可以**设置永远不过期** ，这样就能保证缓存的稳定性，但需要注意在数据更改之后，要及时更新此热点缓存，不然就会造成查询结果的误差。
  - 这里的“永远不过期”包含两层意思：
    1. 从Redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。
    2. 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期

### 缓存预热

**什么是缓存预热？**

> 缓存预热并不是一个问题，而是使用缓存时的**一个优化方案** ，它可以提高前台用户的使用体验。

```
缓存预热指的是在系统启动的时候，先把查询结果预存到缓存中，以便用户后面查询时可以直接从缓存中读取，以节约用户的等待时间
```

**缓存预热实现思路？**

```
1.把需要缓存的方法写在系统初始化的方法中，这样系统在启动的时候就会自动的加载数据并缓存数据。
2.把需要缓存的方法挂载到某个页面或后端接口上，手动触发缓存预热。
3.设置定时任务，定时自动进行缓存预热。
```

## 6.Redis 持久化机制？

### 什么是要持久化，有啥用？
> 简单说就是将内存数据保存到硬盘，防止机器重启后数据丢失。

### 持久化的几种方案？

```
1.快照方案（RDB, Redis DataBase）：将某一个时刻 Redis 的内存数据，以二进制的方案写入磁盘。
2.文件追加方案（AOF, Append Only File）：记录所有的操作命令，并以日志的形式追加到文件中。
3.混合持久化方案：Redis 4.0 之后新增的方案，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。
```

### RDB 优缺点？

```
RDB 优点：
（ 1 ）占用容量小。RDB 的内容为二进制的数据，占用容量更小，更紧凑，更适合做为备份文件。
（ 2 ）传输快（主从复制时是传输 RDB 文件来做的）。RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复。
（ 3 ）提高运行速度。RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I/O 等操作。
（ 4 ）重启快。与 AOF 格式的文件相比，RDB 文件可以更快的重启。

RDB 缺点：
（ 1 ）最新数据丢失。因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据。
（ 2 ）数据集大时，fork() 系统调用占用时间长。RDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。
```

### AOF 优缺点?
```
AOF 优点：
（ 1 ）AOF 持久化保存的数据更加完整。AOF 提供了三种保存策略：每次操作保存、每秒钟保存一次、跟随系统的持久化策略保存，其中每秒保存一次，从数据的安全性和性能两方面考虑是一个不错的选择，也是 AOF 默认的策略，即使发生了意外情况，最多只会丢失 1s 钟的数据。
（ 2 ）AOF 采用的是命令追加的写入方案，所以不会出现文件损坏的问题，即使由于某些意外原因，导致了最后操作的持久化数据写入了一半，也可以通过 redis-check-aof 工具轻松的修复。
（ 3 ）AOF 持久化文件，非常容易理解和解析，它是把所有 Redis 键值操作命令，以文件的方案存入了磁盘。即使不小心使用 flushall 命令删除了所有键值信息，只要使用 AOF 文件，删除最后的flushall 命令，重启 Redis 即可恢复之前误删的数据。

AOF 缺点：
（ 1 ）对于相同的数据集来说，AOF 文件要大于 RDB 文件。
（ 2 ）在 Redis 负载比较高的情况下，RDB 比 AOF 性能更好。
（ 3 ）RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 更健壮。
```
### 混合持久化优缺点？

```
混合持久化优点：
（ 1 ）混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。

混合持久化缺点：
（ 1 ）AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；
（ 2 ）兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前的版本了。
```
[参考：Redis 的持久化](https://juejin.cn/post/7057759186074992654#heading-32)

## 7.Redis 内存淘汰机制？

> 换个问法：
>
> Redis 缓存如何回收?
>
> Redis 有哪几种数据淘汰策略？
>
> Redis 内存淘汰策略？
>
> Redis 是怎么解决缓存占满内存的？

### 说明

```
在 Redis 中，过期策略和内存淘汰策略是两个完全不同的概念。
Redis 过期策略指的是 Redis 使用哪种策略，来删除已经过期的键值对。
Redis 内存淘汰机制指的是，当 Redis 运行内存已经超过 Redis 设置的最大内存之后，将采用什么策略来删除符合条件的键值对，以此来保障 Redis 高效的运行。
```

### 内存淘汰策略

```
早期版本的 Redis 有以下 6 种淘汰策略：
（ 1 ）noeviction：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；
（ 2 ）allkeys-lru：淘汰整个键值中最久未使用的键值；
（ 3 ）allkeys-random：随机淘汰任意键值;
（ 4 ）volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值；
（ 5 ）volatile-random：随机淘汰设置了过期时间的任意键值；
（ 6 ）volatile-ttl：优先淘汰更早过期的键值。

在 Redis 4.0 版本中又新增了 2 种淘汰策略：
（ 1 ）volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值；
（ 2 ）allkeys-lfu：淘汰整个键值中最少使用的键值。

allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰
数据。
```

### 如何修改 Redis 内存淘汰策略？
```
方案一：通过 config set maxmemory-policy 策略 命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。
方案二：通过修改 Redis 配置文件修改，设置 maxmemory-policy 策略，它的优点是重启 Redis服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。
```
[参考：Redis 内存淘汰机制与算法](https://juejin.cn/post/7059326976334495774)

## 8.Redis 过期策略？

> 换个问法：
>
> Redis 如何淘汰过期的keys？
>
> Redis 失效，底层怎么判别时间到了，进行释放的?

```
Redis 会删除已过期的键值，以此来减少 Redis 的空间占用，但因为 Redis 本身是单线的，如果因为删除操作而影响主业务的执行就得不偿失了，为此 Redis 需要制定多个（过期）删除策略来保证正常执行的性能。
Redis 之所以能知道那些键值过期，是因为在 Redis 中维护了一个字典，存储了所有设置了过期时间的键值，我们称之为过期字典。
```

### 定时删除
```
在设置键值过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作。

优点：保证内存可以被尽快地释放。
缺点：在 Redis 高负载的情况下或有大量过期键需要同时处理时，会造成 Redis 服务器卡顿，影响主业务执行。
```

### 惰性删除
```
不主动删除过期键，每次从数据库获取键值时判断是否过期，如果过期则删除键值，并返回 null。

优点：因为每次访问时，才会判断过期键，所以此策略只会使用很少的系统资源。
缺点：系统占用空间删除不及时，导致空间利用率降低，造成了一定的空间浪费。
```
### 定期删除
```
每隔一段时间检查一次数据库，随机删除一些过期键。
Redis 默认每秒进行 10 次过期扫描，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 hz 10。
注意：Redis 每次扫描并不是遍历过期字典中的所有键，而是采用随机抽取判断并删除过期键的形式执行的。

定期删除流程
（ 1 ）从过期字典中随机取出 20 个键。
（ 2 ）删除这 20 个键中过期的键。
（ 3 ）如果过期 key 的比例超过 25%，重复步骤 1 。

同时为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。

优点：通过限制删除操作的时长和频率，来减少删除操作对 Redis 主业务的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。
缺点：内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。
```

### Redis 使用的过期策略
```
Redis 使用的是惰性删除加定期删除的过期策略。
```

[参考：Redis 过期操作与过期策略](https://juejin.cn/post/7058918503255900167#heading-8)

## 9.你们项目中如何保证 Redis 与 MySQL 的数据一致性？
```
方案一：先更新数据库，再更新缓存
方案二：先删除缓存，再更新数据库
方案三：先删除缓存，再更新数据库，再删除缓存（缓存延时双删）
方案四：最终一致性方案（删除缓存重试机制）

方案一：如果先更新数据库在更新缓存，那么如果缓存更新失败，就会导致数据库和Redis中的是数据不一致的
方案二：如果是先删除缓存在更新数据库，理想情况下是应用下次访问Redis的时候，发现Redis里面的数据是空的，那么就会从数据库加载保存到Redis里面，也就是说数据理论上是一致的，但是在极端情况下，由于删除Redis和更新数据库这两个操作并不是原子操作，所以在这个过程中如果其他线程来访问，还是会出现数据不一致的问题。
方案三：先删除缓存，再更新数据库，然后休眠1s（根据具体业务合理设置，比如几百毫秒），再删除缓存。有可能第二次删除失败，还是会导致数据不一致。
方案四：所以如果需要在极端情况下任然去保证Redis和MySQL的数据一致性就只能采用最终一致性的方案，比如基于RabbitMQ的可靠性消息通信来实现数据的最终一致性，还可以直接通过Canal组件监控MySQL里面的binary log日志，把更新后的数据同步到Redis里面，因为这里是基于最终一致性来实现的，如果业务场景不能去接受数据的短期不一致性，那么就不能使用这样的一个方案来实现。
```
##  10.Redis 主从同步和哨兵模式？

### 主从同步
```
主从同步（主从复制）是 Redis 高可用服务的基石，也是多机运行中最基础的一个。
我们把主要存储数据的节点叫做主节点 (master），把其他通过复制主节点数据的副本节点叫做从节点 (slave）。在 Redis 中一个主节点可以拥有多个从节点，一个从节点也可以是其他服务器的主节点。

主从同步具有以下三个优点：
（ 1 ）性能方面：有了主从同步之后，可以把查询任务分配给从服务器，用主服务器来执行写操作，这
样极大的提高了程序运行的效率，把所有压力分摊到各个服务器了；
（ 2 ）高可用：当有了主从同步之后，当主服务器节点宕机之后，可以很迅速的把从节点提升为主节
点，为 Redis 服务器的宕机恢复节省了宝贵的时间；
（ 3 ）防止数据丢失：当主服务器磁盘坏掉之后，其他从服务器还保留着相关的数据，不至于数据全部丢失。
```

### 哨兵模式

```
主从复制模式，它是属于 Redis 多机运行的基础，但这种模式本身存在一个致命的问题，当主节点奔溃之后，需要人工干预才能恢复 Redis 的正常使用。我们需要一个自动的工具 Redis Sentinel（哨兵模式）来把手动的过程变成自动的，让 Redis 拥有自动容灾恢复（failover）的能力。
哨兵就相当于对主从服务器做一个监视的任务。一旦发现主服务器宕机了，就迅速启动相应的规则将某一台从服务器升级为主服务器，无需人工干预，更稳定更快。Redis Sentinel 的最小分配单位是一主一从。

哨兵工作原理：
（ 1 ）首先每个 Sentinel 会以每秒钟 1 次的频率，向已知的主服务器、从服务器和以及其他
Sentinel 实例，发送一个 PING 命令。
（ 2 ）如果最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 所配置的值（默认30s），那么这个实例会被 Sentinel 标记为主观下线。
（ 3 ）如果一个主服务器被标记为主观下线，那么正在监视这个主服务器的所有 Sentinel 节点，要以每秒 1 次的频率确认主服务器的确进入了主观下线状态。
（ 4 ）如果有足够数量（quorum 配置值）的 Sentinel 在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。此时所有的 Sentinel 会按照规则协商自动选出新的主节点。

注意：一个有效的 PING 回复可以是：+PONG、-LOADING 或者 -MASTERDOWN。如果返回值非以上三种回复，或者在指定时间内没有回复 PING 命令， 那么 Sentinel 认为服务器返回的回复无效（non-valid)。
```
[参考：Redis 主从同步和哨兵模式](https://juejin.cn/post/7059607823218376740#heading-15)