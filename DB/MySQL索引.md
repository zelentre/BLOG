---
title: MySQL索引
date: 2022-04-06 16:48:38
categories: 
 - DB
 - MySQL
tags: 
 - MySQL
---
# MySQL索引

> **索引是对数据库表中一列或多列的值进行排序的一种结构。MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。** 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。
>
> 📌简单类比一下，数据库如同书籍，索引如同数据目录，假如我们需要从书籍查找与xx相关的内容，我们可以直接从目录中查找，定位到xx内容所在页面，如果目录中没有xx相关字符或者没有设置目录（索引），那就只能逐字逐页阅读文本查找，效率可想而知。
<!--more-->

## 1. 索引的优缺点

> 索引可以大大提高MySQL的检索速度，为什么不对表中的每一个列创建一个索引呢？

### 1.1. 优点

- **索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要原因**
- **索引可以帮助服务器避免排序和创建临时表**
- **索引可以将随机IO变成顺序IO**
- 索引可以对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组，提高了表访问并发性
- 关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
- 可以加速表与表之间的连接，特别是在实现数据的参考完整性方面特别有意义
- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能

### 1.2. 缺点

- 创建索引和维护索引要**消耗时间**，这种时间随着数据量的增加而增加
- 索引需要占**物理空间**，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大
- 对表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度
-  如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果
- 对于非常小的表，大部分情况下建单的全表扫描更高效

## 2. 创建索引准则

> 索引是建立在数据库表中的某些列的上面。因此，在创建索引的时候，应该仔细考虑在那些列上可以创建索引，在那些列上不能创建索引。
### 2.1. 应该创建索引的列

-   在**经常需要搜索的列**上，可以加快搜索的速度
-   在作为**主键的列**上，强制该列的唯一性和组织表中数据的排列结构
-   在**经常用在连接（JOIN）的列上**，这些列主要是一些外键，可以加快连接的速度
-   在**经常需要根据范围（<, <=, =, >, >=, BETWEEN, IN）进行搜索的列**上创建索引，因为索引已经排序，其指定的范围是连续的
-   在**经常需要排序的（ORDER BY）的列**上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
-   在**经常使用WHERE子句中的列**上创建索引，加快条件的判断速度

### 2.2. 不该创建索引的列

-   对于那些在查询中**很少使用或者参考的列**不应该创建索引。若列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求
-   对于那些只有**很少数据值或者重复值多的列**也不应该增加索引。这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度
-   对于那些定义为**text, image和bit数据类型的列**不应该增加索引。这些列的数据量要么相当大，要么取值很少
-   当该列**修改性能要求远远高于检索性能**时，不应该创建索引。（修改性能和检索性能是相互矛盾的）

## 3. 索引结构

> MySQL中常用的索引结构（索引底层的数据结构）有：B-TREE ，B+TREE ，HASH 等。

### 3.1. B-Tree

**B-树就是B树，多路搜索树，树高一层意味着多一次的磁盘I/O**，下图是3阶B树

![](https://gcore.jsdelivr.net/gh/znej/pic/picgo/2021013023233065.png)

B树的特征：

-   **关键字集合分布在整棵树中**
-   任何一个关键字出现且只出现在一个节点中
-   **搜索有可能在非叶子节点结束**
-   其搜索性能等价于关键字全集内做一次二分查找
-   自动层次控制
    
### 3.2. B+TREE

> B+树是B-树的变体，也是一种多路搜索树

![](https://gcore.jsdelivr.net/gh/znej/pic/picgo/20210130232533425.png)

B+树的特征：

- **所有关键字都出现在叶子节点的链表中（稠密索引），且链表中的关键字恰好是有序的**
- **不可能在非叶子节命中**
- **非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储（关键字）数据的数据层**
- 每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶节点的范围遍历
- 更适合文件索引系统
### 3.2. HASH
> 哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+数那样给从根节点到叶子节点逐级查找，只需一次哈希算法即可立即定位到相应的位置，速度非常高快。

![](https://gcore.jsdelivr.net/gh/znej/pic/picgo/20220308214810.png)

**哈希索引仅仅能满足`"=",“IN"和”<=>"`查询，不能使用范围查询。** 也不支持任何范围查询，例如`WHERE price > 100`。
由于**Hash**索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样。

### 3.3. 补充：索引存储在文件系统中

**索引是占据物理空间的，在不同的存储引擎中，索引存在的文件也不同。**存储引擎室基于表的，以下分别使用MyISAM和InnoDB存储引擎建立两张表。

![存储引擎是基于表的，以下建立两张别使用MyISAM和InnoDB引擎的表，看看其在文件系统中对应的文件存储格式。](https://gcore.jsdelivr.net/gh/znej/pic/picgo/20210130233352294.png)

#### 3.3.1. 存储引擎为MyISAM：

- *.frm：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等
- *.MYD：MyISAM DATA，用于存储MyISAM表的数据
- *.MYI：MyISAM INDEX，用于存储MyISAM表的索引相关信息

#### 3.3.2. 存储引擎为InnoDB：

- *.frm：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等
- *.ibd：InnoDB DATA，表数据和索引的文件。该表的索引（B+树）的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据

## 4. 索引分类

> MySQL的索引有两种分类方式：逻辑分类和物理分类。

### 4.1. 逻辑分类

> 有多种逻辑划分的方式，比如按功能划分，按组成索引的列数划分等

#### 4.1.1. 按功能划分

- 主键索引：一张表只能有一个主键索引，不允许重复、不允许为NULL

  ```sql
  ALTER TABLE TableName ADD PRIMARY KEY(column_list);
  ```

- 唯一索引：数据列不允许重复，允许为NULL值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一

  ```sql
  CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));
  # 或者
  ALTER TABLE TableName ADD UNIQUE (column_list); 
  ```

- 普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许NULL值插入

  ```sql
  CREATE INDEX IndexName ON `TableName`(`字段名`(length));
  # 或者
  ALTER TABLE TableName ADD INDEX IndexName(`字段名`(length));
  ```

- 全文索引：它查找的是文本中的关键字，主要用于全文检索。

#### 4.1.2. 按列数划分

- 单例索引：一个索引只包含一个列，一个表可以有多个单例索引
- 组合索引：一个组合索引可以包含两个或两个以上的列。查询的时候遵循MySQL组合索引的”最左前缀“原则，即使用where时条件要按照建立索引时的字段排列方式放置，索引才会生效

### 4.2. 物理分类

> 物理分类分为聚簇索引和非聚簇索引（有时也称辅助索引或二级索引）

#### 4.2.1. 聚簇索引和非聚簇索引

> 聚簇是为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块

**聚簇索引（clustered index）：不是单独的一种索引类型，而是一种数据存储方式。**这种储存方式是依靠B+树来实现的，**根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据**时，方可称该主键索引为聚簇索引。**聚簇索引也可以理解为将数据存储与索引放到了一块，找到索引也就找到了数据。**

**非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录。**

虽然InnoDB和MyISAM存储引擎都默认使用B+树结构存储索引，但是**只有InnoDB的主键索引才是聚簇索引**，InnoDB中的辅助索引以及MyISAM使用的都是非聚簇索引。**每张表做多只能拥有一个聚簇索引**。

#### 4.2.2. 拓展：聚簇索引优缺点

1. 优点：
   - **数据访问更快**，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引
   - 聚簇索引对于主键的排序查找和范围查找速度非常快
2. 缺点：
   - **插入速度严重依赖于插入顺序**，按照主键的顺序插入时最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键**（主键列不要选没有意义的自增列，选经常查询的条件列才好，不然无法体现其主键索引性能）**
   - **更新主键的代价很高**，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新
   - **二级索引访问需要两次索引查找**，第一次找到主键值，第二次根据主键值找到行数据

### 4.3.【 补充】MySQL中key、primary key、unique key与index区别

#### 4.3.1. key与index含义

key具有两层含义：

1. 约束（约束和规范数据库的结构完整性）
2. 索引

index：索引

#### 4.3.2. key种类

key：等价普通索引`key键名（列）`

primary key：

- 约束作用（constraint），主键约束（unique，not null，一表一主键，唯一标识记录），规范存储主键和强调唯一性
- 为这个key建立主键索引

unique key：

- 约束作用（constraint），unique约束（保证列或者列集合提供唯一性）
- 为这个key建立一个唯一索引

foreign key：

- 约束作用（constraint），外键约束，规范数据的引用完整性
- 为这个key建立一个普通索引

#### 4.3.3. key值类型

- PRI主键约束
- UNI唯一约束
- MUL可以重复

如果一个key有多个约束，将显示约束优先级最高的，**PRI>UNI>MUL**

## 5. InnoDB和MyISM索引实现

### 5.1. InnoDB索引实现

> InnoDB使用B+树存储数据，除了主键索引为聚簇索引，其它索引均为非聚簇索引。一个表中只能存在一个聚簇索引（主键索引），但可以存在多个非聚簇索引。InnoDB表的索引和数据是存储在一起的，`.idb`表数据和索引的文件

#### 5.1.1. 聚簇索引（主键索引）
