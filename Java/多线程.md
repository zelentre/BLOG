---
title：多线程
date: 2020-10-07 14:07:52
categories: 
 - Java
 - 多线程
tags: 
 - 多线程
---

# 多线程

## 一、进程

​	我们都知道计算机的核心是CPU，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件；应用程序是具有某种功能的程序，程序是运行于操作系统之上的。

　　进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。进程一般由程序，数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息是进程存在的唯一标志

进程具有的特征：

动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；

并发性：任何进程都可以同其他进行一起并发执行；

独立性：进程是系统进行资源分配和调度的一个独立单位；

结构性：进程由程序，数据和进程控制块三部分组成

## 二、线程

​	线程，又称轻量级进程（Light Weight Process）。

​	进程中的一条执行路径，也是CPU的基本调度单位。一个进程由一个或多个线程组成，彼此间完成不同的工作，同时执行，称为多线程。

## 三、进程和线程的区别

1. 进程是操作系统资源分配的基本单位，而线程是CPU的基本调度单位
2. 一个程序运行后至少有一个进程。
3. 一个进程可以包含多个线程，但是至少需要有一个线程，否则这个进程是没有意义。
4. 进程间不能共享数据段地址，但同进程的线程之间可以

## 四、线程的组成

- 任何一个线程都具有基本的组成本分：
  - CPU时间片：操作系统会为每个线程分配执行时间。
  - 运行数据：
    - 堆空间：存储线程需要使用的对象，多个线程可以共享堆中的对象。
    - 栈空间：存储线程需要使用的局部变量，每个线程都拥有独立的栈。
  - 线程的逻辑代码

## 五、线程的特点

1. 线程抢占式执行
   - 效率高
   - 可防止单一线程长时间独占CPU
2. 在单核CPU中，宏观上同时执行，微观上顺序执行。

## 六、创建线程

- 创建线程的方式

  1. 继承Thread类，重写run方法

     ```java
     public class TestCreateThread {
         public static void main(String[] args) {
             MyThread myThread = new MyThread();
             myThread.start();
         }
     
         static class MyThread extends Thread {
             @Override
             public void run() {
                 for (int i = 0; i <= 50; i++) {
                     System.out.println("MyThread: " + i);
                 }
             }
         }
     }
     ```

     - 获取线程ID和线程名称
       1. 在Thread的子类中调用this.getId()或this.getName()
       2. 使用Thread.currentThread().getId()和Thread.currentThread().getName()
     - 修改线程名称
       1. 调用线程对象的setName()方法
       2. 使用线程子类的构造方法赋值

  2. 实现Runnable接口

     ```java
     public class MyRunnable implements Runnable{
     
         @Override
         public void run() {
             for (int i = 0; i < 100; i++) {
                 System.out.println(Thread.currentThread().getName()+"*******"+i);
             }
         }
     }
     //
     public class TestRannable {
         public static void main(String[] args) {
             MyRunnable runnable = new MyRunnable();
             Thread thread = new Thread(runnable, "我的线程1");
             thread.start();
     
             //匿名内部类实现
             Thread thread1 = new Thread(new Runnable() {
                 @Override
                 public void run() {
                     System.out.println("*");
                 }
             });
     
         }
     }
     ```

     - 示例

       ```java
        // 四个窗口共卖 100
       public static void main(String[] args) {
               Runnable runnable = new Runnable() {
                   private int ticket = 100;
                   @Override
                   public void run() {
                       while (true) {
                           synchronized (this) {
                               if (ticket <= 0) {
                                   break;
                               }
                               System.out.println(Thread.currentThread().getName() + "****** " + ticket);
                               ticket--;
                               //想要看到线程效果  最好让执行线程停一会 让别的线程执行
                               try {
                                   Thread.sleep(50);
                               } catch (InterruptedException e) {
                                   e.printStackTrace();
                               }
                           }
                       }
                   }
               };
               Thread thread = new Thread(runnable, "窗口1 ");
               Thread thread1 = new Thread(runnable, "窗口2 ");
               Thread thread2 = new Thread(runnable, "窗口3 ");
               Thread thread3 = new Thread(runnable, "窗口4 ");
       
               thread1.start();
               thread.start();
               thread2.start();
               thread3.start();
           }
       ```

       ```java
       // 存取钱
       private double money;
       
           public double getMoney() {
               return money;
           }
       
           public void setMoney(double money) {
               this.money = money;
           }
       
           public static void main(String[] args) {
               BankCard card = new BankCard();
               Thread thread = new Thread(new Runnable() {
                   @Override
                   public void run() {
                       for (int i = 0; i < 10; i++) {
                           card.setMoney(card.getMoney() + 1000);
                           System.err.println(Thread.currentThread().getName() + "add 1000" + "余额" + card.getMoney());
                           try {
                               Thread.sleep(50);
                           } catch (InterruptedException e) {
                               e.printStackTrace();
                           }
                       }
                   }
               },"射手");
               Thread thread1 = new Thread(new Runnable() {
                   @Override
                   public void run() {
                       for (int i = 0; i < 10; i++) {
                           if (card.getMoney() >= 1000) {
                               card.setMoney(card.getMoney() - 1000);
                               System.err.println(Thread.currentThread().getName() + "sub 1000" + "余额" + card.getMoney());
                               try {
                                   Thread.sleep(50);
                               } catch (InterruptedException e) {
                                   e.printStackTrace();
                               }
                           } else {
                               System.err.println("余额不足");
                               i--;
                               try {
                                   Thread.sleep(50);
                               } catch (InterruptedException e) {
                                   e.printStackTrace();
                               }
                           }
                       }
                   }
               },"钉钉");
               thread.start();
               thread1.start();
           }
       ```

  3. 实现Callable接口

## 七、线程的状态（基本）

- 初始状态：线程对象被创建，即为初始状态。