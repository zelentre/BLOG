---
title: RabbitMQ学习
date: 2021-07-17 17:50:03  
categories:
  - rabbitmq
tags:
  - rabbitmq
---

# RabbitMQ学习

**核心概念**

> Server：又称Broker，接受客户端的连接，实现AMQP实体服务
>
> Connection：连接，应用程序与Broker的网络连接TCP/IP/三次握手四次挥手
>
> Channel：网络通道，几乎所有操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对应Channel，每个Channel代表一个会话任务
>
> Message：消息，服务与应用程之间传送的数据，有Properties和body组成，Properties可以对消息进行修饰，比如消息的优先级、延迟等高级特性，body就是消息体的内容
>
> Virtual Host：虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名字的Exchange
>
> Exchange：交换机，接收消息，根据路由键发送消息到绑定的队列（不具备消息存储的能力）
>
> Bindings：Exchange和Queue之间的虚拟连接，binding中可以保护多个routing key
>
> Routing key：是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息
>
> Queue：队列也就是Message Queue，消息队列，保存消息并将它们转发给消费者

<!--more-->

## 一、模式

**Work模式**

> 主要有两种模式：
>
> 1. 轮询模式的分发：一个消费者一条，按均分配
> 2. 公平分发：根据消费者的消费能力进行公平分发，处理的快的处理的多，处理的慢的处理的少；按劳分配

**RabbitMQ使用场景**

>1. 同步异步问题（串行）：将订单信息写入数据库成功后，发送注册邮件，在发送注册短信。以上三个任务全部完成后，返回给客户端
>
>   ![image-20210721145751320](https://fastly.jsdelivr.net/gh/znej/pic/picgo/image-20210721145751320.png)
>
>2. 同步异步问题（并行、异步线程池）：将订单写入数据库成功后，同时进行注册邮件、注册短信的发送，完成以上三个任务后，返回给客户端，与串行的差别是，并行的方式可以提高处理的时间
>
>   ![image-20210721172427071](https://fastly.jsdelivr.net/gh/znej/pic/picgo/image-20210721172427071.png)
>
>   存在问题：
>
>   + 耦合度高
>   + 需要自己写线程池自己维护成本太高
>   + 出现了消息可能丢失，需要做消息补全
>   + 需要考虑如何保证消息的可靠性
>   + 若服务器承载不了，需要自己去写高可用
>
>3. 异步消息队列的方式：
>
>   ![image-20210721173920110](https://fastly.jsdelivr.net/gh/znej/pic/picgo/image-20210721173920110.png)
>
>   好处：
>
>   + 完全解耦，用MQ简历桥接
>
>   + 有独立的线程池和运行模型
>
>   + 出现了消息可能丢失，MQ有持久化功能
>
>   + 如何保证消息的可靠性，死信队列和消息转移等
>
>   + 若服务器承载不了，HA镜像模型高可用，增加集群
>
>     按照以上约定，用户的响应时间相当于是订单信息写入数据库的时间。注册邮件、短信发送写入消息队列后，直接返回（写入消息队列的速度很快，基本可以忽略）。因此架构改变后，系统的吞吐量提高到每秒20QPS，比串行提高了三倍，比并行提高了两倍
>
>4. ![image-20210721175005637](https://fastly.jsdelivr.net/gh/znej/pic/picgo/image-20210721175005637.png)
>
>5. 流量削峰
>
>   ![image-20210721175150300](https://fastly.jsdelivr.net/gh/znej/pic/picgo/image-20210721175150300.png)



**队列绑定关系声明（Configuration）在生产者还是消费者好，其他都可以但是为了防止项目启动报错建议声明在消费者**

## 二、过期时间TTL

1. 什么是TTL
   - time to live 消息存活时间
   - 如果消息在存活时间内未被消费，则会被清除
   - rabbitmq支持两种ttl设置
     - 单独消息进行配置ttl
     - 整个队列进行配置ttl（居多）
     - 若上述两种方法同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。消息在队列的生存时间一旦超过设置的TTL值，就称为dead message被投递到死信队列，消费者将无法在收到改消息。

## 三、死信队列

**概念**：没有被及时消费的消息存放队列

**死信交换机：**Dead Letter Exchange(缩写：DLX)当消息称为死信后，会被重新发送到另一个交换机，这个交换机就是DLX死信交换机。

![image-20210722170415668](https://fastly.jsdelivr.net/gh/znej/pic/picgo/image-20210722170415668.png)

消息变成死信，可能是由于以下的原因：

- 消息被拒绝
- 消息过期
- 队列达到最大长度

DLX也是一个正常的交换机，和一般的交换机没有区别，它能在任何的队列上被指定，实际上就是设置某一个队列的属性，当这个队列存在死信时，rabbitmq就会自动的将这个消息重新发布到设置的DLX上，进而被路由到另一个队列，即死信队列，想要使用死信队列，只需要在定义队列的时候设置队列参数`  x-dead-letter-exchange `指定交换机即可。

**过期时间+死信队列=延时队列**

## 四、集群

​	RabbitMQ本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过通不过Erlang集群各节点的magic cookie来实现）。因此,rabbitmq天然支持clustering。这使得rabbitmq本身不需要像activemq、Kafka那样通过zookeeper分别来实现HA方案和保存集群的元数据。集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。在实际使用过程中多采用多机多实例部署方式。

##　五、面试题分析

1.　Rabbitmq为什么需要信道，为什么不是TCP直接通信？
   - TCP的创建和销毁，开销大，创建要三次握手，销毁要四次分手
   - 如果不用信道，那应用程序就会TCP连接到RabbitMQ服务器，高峰时每秒成千上万连接就会造成资源的巨大浪费，而且**底层操作系统每秒处理tcp连接数也是有限的，必定造成性能瓶颈**。
   - 信道的原理时一条线程一条信道，多条线程多条信道用一条TCP连接，一条TCP连接可以容纳无限的信道，即使每秒成千上万的请求也不会称为性能瓶颈。
2.　queue队列到底在消费者创建还是在生产者创建？
   - 一般建议实在rabbitmq操作面板创建，这是一种稳妥的做法。
   - 按照常理来说，确实应该消费者这边创建是最好，消息的消费是在这边。这样你承受一个后果，可能生产者的生产消息会丢失。
   - 在生产者创建队列也可以，这样稳妥的方法，消息是不会出现丢失。
   - 如果生产者和消费者都创建的队列，谁先启动谁先创建，后面启动的就会覆盖前面的
